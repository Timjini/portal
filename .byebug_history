exit
 attendance.save!
 attendance = Attendance.find_or_initialize_by(
        user_id: user_id,
        attended_at: selected_date
      )
user_id = 111
 attendance = Attendance.find_or_initialize_by(
        user_id: user_id,
        attended_at: selected_date
      )
exit
clear
Date.parse(params[:attendance][:attended_at])
exit
clear
cckear
params[:attendance][:attended_at].inspect
params[:attendance][:attended_at]
exit
items
exit
item
exit
child.map {|c| c.merge(path: send(c["path_helper"])}
child.each do 
child["path_helper"]
child[:path_helper]
child
cild
child["path_helper"]
c= child.merge(path: send(child["path_helper"]))
child.merge(path: send(child["path_helper"]))
child
child.merge(path: send(item["path_helper"]))
child.merge(path: send(child["path_helper"]))
child = item["children"]
item
i
child
item["children"].map {|i| i.merge(i["path_helper"])}
item
exit
item
item["children"]
exit
user.nil?
user = User.where('lower(email) = ?', params[:user][:email].downcase).first
exit
params
exit
user_ids = params['user_ids'].split(',')
 check_lists = CheckList.where(level_id: level_data['id'])
check_lists = CheckList.where(level_id: obj['id'])
 level_data = JSON.parse(params['level']['data'])
full_obj = JSON.parse(params['level'])
exit
exir
levels.each
levels
levels.each do |level|
      level.check_lists << checkLists
    end
checkLists =  []
levels = params[:level][:data]
params[:level][:data]
level[:data]
level['data']
levels
levels = params[:levels]
exit
params[:role]
exit
params
exit
params[:attendance][:user_ids]
params[:attendance]["user_ids"]
params[:attendance]
params[:attendance][0]
a
@cear
continue
exit
TimeSlot.create(
            date: event_date,
            start_time: event_date,
            end_time: event_date + (time_slot.end_time - time_slot.start_time),
            coach_calendar_id: time_slot.coach_calendar_id,
            recurrence_rule: time_slot.recurrence_rule,
            recurrence_end: time_slot.recurrence_end,
            group_type: time_slot.group_type,
            slot_type: time_slot.slot_type,
          )
TimeSlot.create(
            start_time: event_date,
            end_time: event_date + (time_slot.end_time - time_slot.start_time),
            coach_calendar_id: time_slot.coach_calendar_id,
            recurrence_rule: time_slot.recurrence_rule,
            recurrence_end: time_slot.recurrence_end,
            group_type: time_slot.group_type,
            slot_type: time_slot.slot_type,
          )
event_date
exit
recurrence_rule
recurrence = Recurrence.new(recurrence_rule_hash)
exit
recurrence = Recurrence.new(recurrence_rule_hash)
exit
recurrence_rule
recurrence_rule = {
        every: recurrence_rule.to_sym,
        on: formatted_day,
        until: recurrence_end
      }.compact
formatted_day
      recurrence = Recurrence.new(recurrence_rule)
exit
      recurrence_rule = { every: recurrence_rule.to_sym, on: formatted_day ,  until: recurrence_end }.compact
formatted_day = day.strftime('%A').downcase.to_sym
day = Time.now
recurrence = Recurrence.new(recurrence_rule)
exit
formatted_day.to_sym
      recurrence = Recurrence.new(recurrence_rule)
recurrence_rule
exit
recurrence = Recurrence.new(recurrence_rule)
exit
recurrence
exit
params['time_slot']['start_time']
params['time_slot']['start_time'
params['time_slot']
params['time_slot'
params
params[:start_time]
params['start_time']
params.start_time
start_time
params[:start_time]
paams
paras
paraarams
exit
@levels
exit
params[:level]
@levels
p
payoad
ploadayload
yloa
p
payod
exit
child
parent
